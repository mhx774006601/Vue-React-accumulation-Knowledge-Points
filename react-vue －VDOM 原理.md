VUE虚拟原理：

　　　 VUE编译过程是怎样的？遵循3W1h原则(What——什么事情？（对象）；When——什么时间执行？什么时间完成？（时间）；
      Who——由谁执行？（人员）；How——怎样执行？采取哪些有效措施？（方法）。)。
     首先这个编译是vue模板写的这些语句html根本就不识别，我们通过编译的过程可以进行依赖收集，
     进行依赖收集以后我们就把我们的data中的数据模型和视图之间产生了绑定关系，产生了依赖关系，
     以后如果模型发生变化的时侯我们就可以通知依赖这些地方，让他们进行更新。这就是我们执行编译的目的。
      我们把这些界面全部编译以后，执行更新操作，然后我们就可以做到模型驱动视图的变化。这就是编译过程。这就是它的作用。

　　　   双向绑定的原理是什么？我们在双向绑定的时候，通常会使用v-model这样的一个指令，放在input这样的元素上。
    我们在编译的时候可以解析出这个v-model,然后我在做操作的时候，有两件事情，第一件事情：我把当前v-model所属元素上面加了一个事件监听，
    我把v-model指向的回调函数作为input事件监听的回调函数，去监听。如果input发生变化的时候，我就可以把最新的值设置到vue的实例上，
     那么因为vue的这个实例实现了这个数据的响应化，它的响应化的setter函数会触发界面中所有模型依赖的更新，会通知所有那些依赖去做更新和刷新操作。
    所以界面中的跟这个数据相关的所有部分就更新了。



React虚拟DOM原理：

React虚拟DOM是通过与真实DOM的比较去减少重排或者重绘的次数，这算是做虚拟DOM的目的，通过对虚拟层每次变化的比较，不直接更新DOM，而是比较出我应不应该去做更新，或者更新尽可能批量的或者一次性的去做最少的更新，尽量减少实际的真实DOM操作，这样浏览器的刷新次数就少，性能就高一些。
What? 用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。这个 JavaScript 对象称为virtual dom；
Why?  Dom操作很慢，轻微的操作都可能导致页面重新排版，非常耗性能，相对于DOM对象，JS对象处理起来更快，而且更简单。通过diff算法对比新旧Vdom 之间的差异，可以批量的最小化的执行dom操作，从而提高性能。
Where? React中用jsx语法描述视图，通过babel-loader转译后它们变为React.createElement(...)形式，该函数将生成vdom来描述真实dom.将来如何状态变化，vdom将作出相应变化，再通过diff算法对比新老vdom区别从而做出最终dom操作。
How?  Diff算法/diff策略
diff策略:
1.同级比较，Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
   也就是在比较的时候，只会同级比较，
2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
例如：div->p, CompA->CompB
在同级比较的时候，先看两个元素的类型，如果一个A和一个B，如果A是div,B是H2，那就其它的不用看了，它俩就认为不同了，节点类型都不同了，就直接干掉，换成最新的就行了。
节点类型比较，先判断类型，再判断属性，依次递归的去比较，如果是原生的节点，看它的style有没有变化，classname有没有变化等等，再比属性，发现都没有变化，那就接着去看下一层，接着比。那刚才那个比较就结束了，它不会做更新。这是一种比较方式 。如果我是class或者function进行比较，就要看是不是两个相同的class或者两个相同的function。如果两个class相同，那就接着去看class里面的部分，如果进去就又变成最底层原生dom的比较了。
3. 对于同一层级的一组子节点，通过唯一的key进行区分。
   如果对于同一级的列表，比如说ul ,li ,这时候会用key去进行区分，如果有key,就直接用key来说它俩相不相同，如果key相同就说明是一样的，不管其它是啥样，只要key相同就说它相同。

在进行元素比较的时候，会有如下几种方式：
差异类型：
1. 替换原来的节点，例如把div换成了p，Comp1换成Comp2
2. 移动、删除、新增子节点， 例如ul中的多个子节点li中出现了顺序互换。
3. 修改了节点的属性，例如节点类名发生了变化。
4. 对于文本节点，文本内容可能会改变。
